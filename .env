const Discord = require('discord.js');
const client = new Discord.Client();

const { Logger } = require('loggers');
const logger = new Logger();

let prefix = '.env ';
let owners = ['306557645479870464', '694963006970527826', '544676649510371328', '277183033344524288'];

client.on('ready', () => logger.log(client.user.tag, "is ready"));

client.on('message', async message => {
  try {
    if (message.author.bot || !message.content.toLowerCase().startsWith(prefix)) return;
    const user = message.mentions.users.first() || message.author;
    const args = message.content.slice(prefix.length).trim().split(/ +/g);
    const command = args.shift().toLowerCase();
    logger.log('Running command', command)
    switch (command.toLowerCase()) {
      case 'help': {
        message.channel.send('My commands:\n\`serverinfo\`\n\`userinfo\`');
        break;
      }
      case 'serverinfo': {
        // Voltrex you do this one
        await message.channel.send(`Server name: ${Discord.Util.escapeMarkdown(message.guild.name)}\nTotal members: ${message.guild.memberCount.toLocaleString()}`);
        break;
      }
      case 'userinfo': {
        // Voltrex you do this one
        await message.channel.send(`Tag: ${Discord.Util.escapeMarkdown(user.tag)}\nID: ${user.id}`);
        break;
      }
      case 'ping': {
        const msg = await message.channel.send('Pinging...');
        await msg.edit(`Roundtrip latency: ${msg.createdTimestamp - message.createdTimestamp}ms\nWebsocket heartbeat: ${client.ws.ping}ms.`);
        break;
      }
      case 'eval': {
        if (!owners.includes(message.author.id)) {
          await message.channel.send('Owner only command.');
          break;
        }
        if (!args[0]) {
          await message.channel.send('Code required to evaluate.');
          break;
        }
        let output;
        try {
          let evaled = eval(args.join(' '));
          if (evaled instanceof Promise) evaled = await evaled;
          function clean(text) {
            return typeof text === 'string' ? text.replace(/(`|@)/g, String.fromCharCode(8203)) : text;
          }
          if (typeof evaled !== 'string') evaled = require('util').inspect(evaled);
          output = clean(evaled);
        } catch (err) {
          output = err.toString();
        }
        await message.channel.send([...output].slice(0, 2048).join(''), {
          code: 'js'
        });
        break;
      }
      case 'ban': {
        const banned = message.mentions.users.first() || client.users.resolve(args[0]);
        if (message.author === banned) {
          const cantbanselfEmbed = new Discord.MessageEmbed()
            .setDescription(`You cannot ban yourself`)
            .setColor("#2C2F33");
          await message.channel.send(cantbanselfEmbed);
          break;
        }
        if (!message.member.permissions.has("BAN_MEMBERS")) {
          const nopermsEmbed = new Discord.MessageEmbed()
            .setDescription("You do not have permission `BAN MEMBERS`.")
            .setColor("#2C2F33");
          await message.channel.send(nopermsEmbed);
          break;
        }
        if (!message.guild.me.permissions.has("BAN_MEMBERS")) {
          const nopermsEmbed = new Discord.MessageEmbed()
            .setDescription("I do not have `BAN MEMBERS` permission.")
            .setColor("#2C2F33");
          await message.channel.send(nopermsEmbed);
          break;
        }
        await message.guild.members.ban(banned);
        const successfullyembed = new Discord.MessageEmbed()
          .setTitle(`${banned.tag} has been successfully banned.`)
          .setColor("#2C2F33");
        await message.channel.send(successfullyembed);
        break;
      }
    }
  } catch (err) {
    const errorEmbed = new Discord.MessageEmbed()
      .setTitle(err)
      .setColor("#FF0000");
    message.channel.send(errorEmbed);
  }
});

client.login('Nzk1NzIwMjkyMTQ3MTM0NTU1.X_NeRQ.Z5OwO5qt-L-Wiz1SCyAKQ5egzxI');
