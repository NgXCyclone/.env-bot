const Discord = require('discord.js');
const client = new Discord.Client();

const { Logger } = require('loggers');
const logger = new Logger();

let prefix = '.env';
let owners = ['306557645479870464', '694963006970527826', '544676649510371328', '277183033344524288'];

client.on('ready', () => logger.log(client.user.tag, 'is ready'));

client.on('message', async message => {
  try {
    if (message.author.bot || !message.content.toLowerCase().startsWith(prefix)) return;
    const user = message.mentions.users.first() || message.author;
    const args = message.content.slice(prefix.length).trim().split(/ +/g);
    const command = args.shift().toLowerCase();
    logger.log('Running command', command)
    switch (command.toLowerCase()) {
      case 'help': {
        return message.channel.send('My commands:\n\`serverinfo\`\n\`userinfo\`');
      }
      case 'serverinfo': {
        // Voltrex you do this one
        return message.channel.send(`Server name: ${Discord.Util.escapeMarkdown(message.guild.name)}\nTotal members: ${message.guild.memberCount.toLocaleString()}`);
      }
      case 'userinfo': {
        // Voltrex you do this one
        return message.channel.send(`Tag: ${Discord.Util.escapeMarkdown(user.tag)}\nID: ${user.id}`);
      }
      case 'ping': {
        const msg = await message.channel.send('Pinging...');
        return msg.edit(`Roundtrip latency: ${msg.createdTimestamp - message.createdTimestamp}ms\nWebsocket heartbeat: ${client.ws.ping}ms.`);
      }
      case 'eval': {
        if (!owners.includes(message.author.id)) return message.channel.send('Owner only command.');
        if (!args[0]) return message.channel.send('Code required to evaluate.');
        let output;
        try {
          let evaled = eval(args.join(' '));
          if (evaled instanceof Promise) evaled = await evaled;
          function clean(text) {
            return typeof text === 'string' ? text.replace(/(`|@)/g, String.fromCharCode(8203)) : text;
          }
          if (typeof evaled !== 'string') evaled = require('util').inspect(evaled);
          output = clean(evaled);
        } catch (err) {
          output = err.toString();
        }
        return message.channel.send([...output].slice(0, 2048).join(''), {
          code: 'js'
        });
      }
      case 'ban': {
        if (!message.member.permissions.has('BAN_MEMBERS')) {
          const nopermsEmbed = new Discord.MessageEmbed()
            .setDescription('You don\'t seem to have `Ban Members` permission')
            .setColor('#2C2F33');
          return message.channel.send(nopermsEmbed);
        }
        if (!message.guild.me.permissions.has('BAN_MEMBERS')) {
          const nopermsEmbed = new Discord.MessageEmbed()
            .setDescription('I require the `Ban Members` permission to perform this action')
            .setColor('#2C2F33');
          return message.channel.send(nopermsEmbed);
        }
        const banned = message.mentions.members.first() || message.guild.members.cache.get(args[0]);
        if (message.author.id === banned.user.id) {
          const cantbanselfEmbed = new Discord.MessageEmbed()
            .setDescription('You cannot ban yourself')
            .setColor('#2C2F33');
          return message.channel.send(cantbanselfEmbed);
        }
        if (!banned.bannable) {
          const notBannable = new Discord.MessageEmbed()
            .setColor('#2C2F33')
            .setDescription('I can\'t ban a member that has a higher role than my roles');
          return message.channel.send(notBannable);
        }
        await banned.ban();
        const successfullyembed = new Discord.MessageEmbed()
          .setDescription(`${Discord.Util.escapeMarkdown(banned.user.tag)} has been successfully banned.`)
          .setColor('#2C2F33');
        return message.channel.send(successfullyembed);
      }
    }
  } catch (err) {
    const errorEmbed = new Discord.MessageEmbed()
      .setDescription(err)
      .setColor('#FF0000');
    return message.channel.send(errorEmbed);
  }
});

client.login('token');
