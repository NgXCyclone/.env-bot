const Discord = require('discord.js');
const client = new Discord.Client();
const Statcord = require('statcord.js');
const moment = require('moment');
const fs = require('fs');

const { Logger } = require('loggers');
const logger = new Logger();

let prefix = '.env ';
let owners = ['306557645479870464', '694963006970527826', '544676649510371328', '277183033344524288'];

const statcord = new Statcord.Client({
  client,
  key: 'statcord.com-TOKEN',
  postCpuStatistics: true, 
  postMemStatistics: true, 
  postNetworkStatistics: true,
});

statcord.on('autopost-start', () => console.log('Started autopost'));

client.on('ready', () => {
  logger.log(client.user.tag, 'is ready');
  statcord.autopost();
});

client.on('message', async message => {
  try {
    if (message.author.bot || !message.content.toLowerCase().startsWith(prefix)) return;
    const member = message.mentions.members.first() || message.member;
    const args = message.content.slice(prefix.length).trim().split(/ +/g);
    const command = args.shift().toLowerCase();
    logger.log('Running command', command);
    statcord.postCommand(command, message.author.id);
    switch (command) {
      case 'help': {
        const helpEmbed = new Discord.MessageEmbed()
        .setDescription(`My commands:\n${[...fs.readFileSync('./.env', 'utf8').match(/case '(.*)': \{/g)].map(c => `\`${c[1]}\``).join('\n')}`);

        return message.channel.send(helpEmbed);
      }
      case 'serverinfo': {
        const owner = await message.guild.members.fetch(message.guild.ownerID);
        const serverinfoEmbed = new Discord.MessageEmbed()
        .setDescription(`**Server name**: ${Discord.Util.escapeMarkdown(message.guild.name)}\n**Server ID**: ${message.guild.id}\n**Server Owner**: ${Discord.Util.escapeMarkdown(owner.user.tag)}\n**Total Members**: ${message.guild.memberCount.toLocaleString()}\n**Total Roles**: ${message.guild.roles.cache.size.toLocaleString()}`)
        return message.channel.send(serverinfoEmbed);
      }
      case 'userinfo': {
        const userinfoEmbed = new Discord.MessageEmbed()
        .setDescription(`**Tag**: ${Discord.Util.escapeMarkdown(member.user.tag)}\n**ID**: ${member.user.id}\n**Time Created:** ${moment(member.user.createdTimestamp).format('ddd, MMM Do, YYYY h:mm:ss A')} (${moment(member.user.createdTimestamp).fromNow()})\n**Server Join Date:** ${moment(member.joinedTimestamp).format('ddd, MMM Do, YYYY h:mm:ss A')} (${moment(member.joinedTimestamp).fromNow()}`);
        return message.channel.send(userinfoEmbed);
      }
      case 'ping': {
        const msg = await message.channel.send('Pinging...');
        return msg.edit(`Roundtrip latency: ${msg.createdTimestamp - message.createdTimestamp}ms\nWebsocket heartbeat: ${client.ws.ping}ms.`);
      }
      case 'eval': {
        if (!owners.includes(message.author.id)) return message.channel.send('Owner only command.');
        if (!args[0]) return message.channel.send('Code required to evaluate.');
        let output;
        try {
          let evaled = eval(args.join(' '));
          if (evaled instanceof Promise) evaled = await evaled;
          function clean(text) {
            return typeof text === 'string' ? text.replace(/(`|@)/g, String.fromCharCode(8203)) : text;
          }
          if (typeof evaled !== 'string') evaled = require('util').inspect(evaled);
          output = clean(evaled);
        } catch (err) {
          output = err.toString();
        }
        return message.channel.send([...output].slice(0, 2048).join(''), {
          code: 'js'
        });
      }
      case 'ban': {
        if (!message.member.permissions.has('BAN_MEMBERS')) {
          const nopermsEmbed = new Discord.MessageEmbed()
            .setDescription('You don\'t seem to have `Ban Members` permission')
            .setColor('#2C2F33');
          return message.channel.send(nopermsEmbed);
        }
        if (!message.guild.me.permissions.has('BAN_MEMBERS')) {
          const nopermsEmbed = new Discord.MessageEmbed()
            .setDescription('I require the `Ban Members` permission to perform this action')
            .setColor('#2C2F33');
          return message.channel.send(nopermsEmbed);
        }
        const banned = message.mentions.members.first() || message.guild.members.cache.get(args[0]);
        if (!banned) {
          const usernotmentioned = new Discord.MessageEmbed()
          .setDescription('Plese mention a user.')
          .setColor('#2C2F33');
          return message.channel.send(usernotmentioned);
        }
        if (message.author.id === banned.user.id) {
          const cantbanselfEmbed = new Discord.MessageEmbed()
            .setDescription('You cannot ban yourself')
            .setColor('#2C2F33');
          return message.channel.send(cantbanselfEmbed);
        }
        if (!banned.bannable) {
          const notBannable = new Discord.MessageEmbed()
            .setColor('#2C2F33')
            .setDescription('I can\'t ban a member that has a higher role than my roles');
          return message.channel.send(notBannable);
        }
        await banned.ban();
        const successfullyembed = new Discord.MessageEmbed()
          .setDescription(`${Discord.Util.escapeMarkdown(banned.user.tag)} has been successfully banned.`)
          .setColor('#2C2F33');
        return message.channel.send(successfullyembed);
      }
      case 'kick': {
        if (!message.member.permissions.has('KICK_MEMBERS')) {
          const nopermsEmbed = new Discord.MessageEmbed()
            .setDescription('You don\'t seem to have `Kick Members` permission')
            .setColor('#2C2F33');
          return message.channel.send(nopermsEmbed);
        }
        if (!message.guild.me.permissions.has('KICK_MEMBERS')) {
          const nopermsEmbed = new Discord.MessageEmbed()
            .setDescription('I require the `Kick Members` permission to perform this action')
            .setColor('#2C2F33');
          return message.channel.send(nopermsEmbed);
        }
        const kicked = message.mentions.members.first() || message.guild.members.cache.get(args[0]);
        if (!kicked) {
          const usernotmentioned = new Discord.MessageEmbed()
          .setDescription('Plese mention a user.')
          .setColor('#2C2F33');
          return message.channel.send(usernotmentioned);
        }
        if (message.author.id === kicked.user.id) {
          const cantkickselfEmbed = new Discord.MessageEmbed()
            .setDescription('You cannot kick yourself')
            .setColor('#2C2F33');
          return message.channel.send(cantkickselfEmbed);
        }
        if (!kicked.kickable) {
          const notKickable = new Discord.MessageEmbed()
            .setColor('#2C2F33')
            .setDescription('I can\'t kick a member that has a higher role than my roles');
          return message.channel.send(notKickable);
        }
        await kicked.kick();
        const successfullyembed = new Discord.MessageEmbed()
          .setDescription(`${Discord.Util.escapeMarkdown(kicked.user.tag)} has been successfully kicked.`)
          .setColor('#2C2F33');
        return message.channel.send(successfullyembed);
      }

      case 'restart': {
        if (!owners.includes(message.author.id)) return message.channel.send('Owner only command.');
        return process.exit();
      }
    }
  } catch (err) {
    const errorEmbed = new Discord.MessageEmbed()
      .setDescription(err)
      .setColor('#FF0000');
    return message.channel.send(errorEmbed);
  }
});

client.login('token');
